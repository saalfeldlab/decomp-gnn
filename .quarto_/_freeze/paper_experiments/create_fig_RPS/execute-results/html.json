{
  "hash": "8e9b89f2e575e6a95a1b3a19b3662dc7",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Training GNN on reaction-diffusion (rock-paper-scissors)\nauthor: CÃ©dric Allier, Michael Innerberger, Stephan Saalfeld\ncategories:\n  - Particles\nexecute:\n  echo: false\nimage: \"create_fig_RPS_files/figure-html/cell-4-output-1.png\"\n---\n\n\n\n\nThis script generates Supplementary Figure 17.\nIt showcases a Graph Neural Network (GNN) learning the dynamics of a reaction-diffusion system.\nThe training simulation involves 1E4 mesh nodes observed over 4E3 frames.\nNode interactions follow rock-paper-scissors rules with different diffusion coefficients.\n\n\n\nFirst, we load the configuration file and set the device.\n\n::: {#c099b2d0 .cell execution_count=2}\n``` {.python .cell-code}\nconfig_file = 'RD_RPS'\nfigure_id = 'supp17'\nconfig = ParticleGraphConfig.from_yaml(f'./config/{config_file}.yaml')\ndevice = set_device(\"auto\")\n```\n:::\n\n\nThe following model is used to simulate the 'rock-paper-scissor' model with PyTorch Geometric.\n\n::: {#897258d4 .cell execution_count=3}\n``` {.python .cell-code}\nclass RDModel(pyg.nn.MessagePassing):\n    \"\"\"Interaction Network as proposed in this paper:\n    https://proceedings.neurips.cc/paper/2016/hash/3147da8ab4a0437c15ef51a5cc7f2dc4-Abstract.html\"\"\"\n\n    \"\"\"\n    Compute the reaction diffusion according to the rock paper scissor model.\n\n    Inputs\n    ----------\n    data : a torch_geometric.data object\n    Note the Laplacian coeeficients are in data.edge_attr\n\n    Returns\n    -------\n    increment : float\n        the first derivative of three scalar fields u, v and w\n\n    \"\"\"\n\n    def __init__(self, aggr_type=[], bc_dpos=[], coeff = []):\n        super(RDModel, self).__init__(aggr='add')  # \"mean\" aggregation.\n\n        self.bc_dpos = bc_dpos\n        self.coeff = coeff\n        self.a = 0.6\n\n    def forward(self, data):\n        x, edge_index, edge_attr = data.x, data.edge_index, data.edge_attr\n\n        c = self.coeff\n\n        uvw = data.x[:, 6:9]\n        laplace_uvw = c * self.propagate(data.edge_index, uvw=uvw, discrete_laplacian=data.edge_attr)\n        p = torch.sum(uvw, axis=1)\n\n        d_uvw = laplace_uvw + uvw * (1 - p[:, None] - self.a * uvw[:, [1, 2, 0]])\n        # This is equivalent to the nonlinear reaction diffusion equation:\n        #   du = D * laplace_u + u * (1 - p - a * v)\n        #   dv = D * laplace_v + v * (1 - p - a * w)\n        #   dw = D * laplace_w + w * (1 - p - a * u)\n\n        return d_uvw\n\n    def message(self, uvw_j, discrete_laplacian):\n        return discrete_laplacian[:, None] * uvw_j\n\n\ndef bc_pos(x):\n    return torch.remainder(x, 1.0)\n\n\ndef bc_dpos(x):\n    return torch.remainder(x - 0.5, 1.0) - 0.5\n```\n:::\n\n\nThe coefficients of diffusion are loaded from a tif file specified in the config yaml file and the data is generated.\n\nVizualizations of the reaction diffusion can be found in \"decomp-gnn/paper_experiments/graphs_data/RD_RPS/\"\n\nIf the simulation is too large, you can decrease n_particles and n_nodes in \"RD_RPS.yaml\".\n\n::: {#09ed764b .cell execution_count=4}\n``` {.python .cell-code}\nmodel = RDModel(\n    aggr_type='add',\n    bc_dpos=bc_dpos)\n\ngenerate_kwargs = dict(device=device, visualize=True, run_vizualized=0, style='color', erase=False, save=True, step=50)\ntrain_kwargs = dict(device=device, erase=True)\ntest_kwargs = dict(device=device, visualize=True, style='color', verbose=False, best_model='20', run=0, step=20)\n\n# data_generate_mesh(config, model , **generate_kwargs)\n```\n:::\n\n\n::: {#0a0374cb .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![Initial configuration of the simulation. There are 1E4 nodes. The colors indicate the node vector values.](create_fig_RPS_files/figure-html/cell-6-output-1.png){width=470 height=470}\n:::\n:::\n\n\n::: {#18420562 .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![Frame 3750 out of 4000](create_fig_RPS_files/figure-html/cell-7-output-1.png){width=470 height=470}\n:::\n:::\n\n\nThe  GNN model (see src/ParticleGraph/models/Mesh_RPS.py) is optimized using the 'rock-paper-scissor' data.\n\nSince we ship the trained model with the repository, this step can be skipped if desired.\n\n::: {#3b9b2c2a .cell execution_count=7}\n``` {.python .cell-code}\nif not os.path.exists(f'log/try_{config_file}'):\n    data_train(config, config_file, **train_kwargs)\n```\n:::\n\n\nThe model that has been trained in the previous step is used to generate the rollouts.\nThe rollout visualization can be found in `paper_experiments/log/try_RD_RPS/tmp_recons`.\n\n::: {#ad3bc6ef .cell execution_count=8}\n``` {.python .cell-code}\ndata_test(config, config_file, **test_kwargs)\n```\n:::\n\n\nFinally, we generate the figures that are shown in Supplementary Figure 17.\nThe results of the GNN post-analysis are saved into 'decomp-gnn/paper_experiments/log/try_RD_RPS/results'.\n\n::: {#d38f7998 .cell execution_count=9}\n``` {.python .cell-code}\nconfig_list, epoch_list = get_figures(figure_id, device=device)\n```\n:::\n\n\n",
    "supporting": [
      "create_fig_RPS_files"
    ],
    "filters": [],
    "includes": {}
  }
}