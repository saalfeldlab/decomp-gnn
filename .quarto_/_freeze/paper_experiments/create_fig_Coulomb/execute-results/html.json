{
  "hash": "6aa1d23ef315391e07d5bf2c1034068d",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Training GNN on Coulomb-like system\nauthor: CÃ©dric Allier, Michael Innerberger, Stephan Saalfeld\ncategories:\n  - Particles\nexecute:\n  echo: false\nimage: \"create_fig_Coulomb_files/figure-html/cell-4-output-1.png.png\"\n---\n\n\n\n\nThis script generates figures shown in Supplementary Figure 8.\nA GNN learns the motion rules governing a gravity-like system\nThe simulation used to train the GNN consists of 960 particles of 16 different masses.\nThe particles interact with each other according to gravity law.\n\n\n\nFirst, we load the configuration file and set the device.\n\n::: {#237e8575 .cell execution_count=2}\n``` {.python .cell-code}\nconfig_file = 'Coulomb_3_256'\nfigure_id = 'supp8'\nconfig = ParticleGraphConfig.from_yaml(f'./config/{config_file}.yaml')\ndevice = set_device(\"auto\")\n```\n:::\n\n\nThe following model is used to simulate the gravity-like system with PyTorch Geometric.\n\n::: {#5e35ddc2 .cell execution_count=3}\n``` {.python .cell-code}\nclass CoulombModel(pyg.nn.MessagePassing):\n        \"\"\"Interaction Network as proposed in this paper:\n        https://proceedings.neurips.cc/paper/2016/hash/3147da8ab4a0437c15ef51a5cc7f2dc4-Abstract.html\"\"\"\n\n        \"\"\"\n        Compute the acceleration of charged particles as a function of their relative position according to the Coulomb law.\n\n        Inputs\n        ----------\n        data : a torch_geometric.data object\n\n        Returns\n        -------\n        pred : float\n            the acceleration of the particles (dimension 2)\n        \"\"\"\n\n        def __init__(self, aggr_type=[], p=[], clamp=[], pred_limit=[], bc_dpos=[]):\n            super(CoulombModel, self).__init__(aggr='add')  # \"mean\" aggregation.\n\n            self.p = p\n            self.clamp = clamp\n            self.pred_limit = pred_limit\n            self.bc_dpos = bc_dpos\n\n        def forward(self, data):\n            x, edge_index = data.x, data.edge_index\n            edge_index, _ = pyg_utils.remove_self_loops(edge_index)\n            particle_type = to_numpy(x[:, 5])\n            charge = self.p[particle_type]\n            dd_pos = self.propagate(edge_index, pos=x[:, 1:3], charge=charge[:, None])\n            return dd_pos\n\n        def message(self, pos_i, pos_j, charge_i, charge_j):\n            distance_ij = torch.sqrt(torch.sum(self.bc_dpos(pos_j - pos_i) ** 2, axis=1))\n            direction_ij = self.bc_dpos(pos_j - pos_i) / distance_ij[:, None]\n            dd_pos = - charge_i * charge_j * direction_ij / (distance_ij[:, None] ** 2)\n            return dd_pos\n\n\ndef bc_pos(x):\n    return torch.remainder(x, 1.0)\n\n\ndef bc_dpos(x):\n    return torch.remainder(x - 0.5, 1.0) - 0.5\n```\n:::\n\n\nThe data is generated with the above Pytorch Geometric model.\nNote two datasets are generated, one for training and one for validation.\nIf the simulation is too large, you can decrease n_particles (multiple of 3) in \"Coulomb_3_256.yaml\".#\n\n::: {#37d4ac22 .cell execution_count=4}\n``` {.python .cell-code}\np = torch.squeeze(torch.tensor(config.simulation.params))\nmodel = CoulombModel(aggr_type=config.graph_model.aggr_type, p=torch.squeeze(p),\n                          clamp=config.training.clamp, pred_limit=config.training.pred_limit, bc_dpos=bc_dpos)\n\ngenerate_kwargs = dict(device=device, visualize=True, run_vizualized=0, style='color', alpha=1, erase=True, save=True, step=10)\ntrain_kwargs = dict(device=device, erase=True)\ntest_kwargs = dict(device=device, visualize=True, style='color', verbose=False, best_model='20', run=0, step=20, save_velocity=True)\n\ndata_generate_particles(config, model, bc_pos, bc_dpos, **generate_kwargs)\n```\n:::\n\n\n::: {#eae0d4b9 .cell execution_count=5}\n\n::: {.cell-output .cell-output-display}\n![Initial configuration of the simulation. There are 960 particles. The colors indicate different charges.](create_fig_Coulomb_files/figure-html/cell-6-output-1.png){width=470 height=470}\n:::\n:::\n\n\n::: {#574afe6c .cell execution_count=6}\n\n::: {.cell-output .cell-output-display}\n![Frame 1800 out of 2000](create_fig_Coulomb_files/figure-html/cell-7-output-1.png){width=470 height=470}\n:::\n:::\n\n\nThe GNN model (see src/ParticleGraph/models/Interaction_Particle.py) is trained and tested.\n\nSince we ship the trained model with the repository, this step can be skipped if desired.\n\n::: {#6f63c0c2 .cell execution_count=7}\n``` {.python .cell-code}\nif not os.path.exists(f'log/try_{config_file}'):\n    data_train(config, config_file, **train_kwargs)\n```\n:::\n\n\nDuring training the embedding is saved in\n\"paper_experiments/log/try_gravity_16/tmp_training/embedding\"\nThe plot of the pairwise interactions is saved in\n\"paper_experiments/log/try_gravity_16/tmp_training/function\"\n\nThe model that has been trained in the previous step is used to generate the rollouts.\n\n::: {#b8d2ee7f .cell execution_count=8}\n``` {.python .cell-code}\ndata_test(config, config_file, **test_kwargs)\n```\n:::\n\n\nFinally, we generate the figures that are shown in Supplementary Figure 7.\nThe results of the GNN post-analysis are saved into 'decomp-gnn/paper_experiments/log/try_Coulomb_3_256/results'.\n\n::: {#473db41b .cell execution_count=9}\n``` {.python .cell-code}\nconfig_list, epoch_list = get_figures(figure_id, device=device)\n```\n:::\n\n\n::: {#18d4ece5 .cell execution_count=10}\n\n::: {.cell-output .cell-output-display}\n![Learned latent vectors (x960)](create_fig_Coulomb_files/figure-html/cell-11-output-1.png){width=470 height=470}\n:::\n:::\n\n\n::: {#962f5d9e .cell execution_count=11}\n\n::: {.cell-output .cell-output-display}\n![Learned interaction functions](create_fig_Coulomb_files/figure-html/cell-12-output-1.png){width=470 height=470}\n:::\n:::\n\n\n::: {#85bd0c29 .cell execution_count=12}\n\n::: {.cell-output .cell-output-display}\n![GNN rollout inference at frame 1980](create_fig_Coulomb_files/figure-html/cell-13-output-1.png){width=470 height=470}\n:::\n:::\n\n\nAll frames can be found in \"decomp-gnn/paper_experiments/log/try_Coulomb_3_256/tmp_recons/\"\n\n\n",
    "supporting": [
      "create_fig_Coulomb_files"
    ],
    "filters": [],
    "includes": {}
  }
}